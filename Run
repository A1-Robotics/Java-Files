//Positive turning is right

//TODO 	clean up the print out
//		simplify each section into its own function, including stuff like the dynamic wall


import rxtxrobot.*;

public class Run {
	int runnumber;
	public static Run run1 = new Run(1);
	public static RXTXRobot r = new ArduinoUno(); // Create RXTXRobot object
	
//======================== Pins =======================//	
	// Digital Pins
	final private static int PING_PIN = 11;
	final private static int servo1pin = 9; //boom arm servo
	final private static int servo2pin = 8; //ping pong ball servo	
	final private static int motor1pin = 5;
	final private static int motor2pin = 6;
	
	// Analog Pins
	final private static int bsAnalogPin = 2;
	final private static int tempPinNumber = 0; //ping pong ball
	final private static int windPinNumber = 1; //open thermister 

//================== Other variables ==================//
	final private static double backup =  -.2; //this is the distance in meters the robot should back up after bumping the wall in order to turn
	final private static int pausetime = 1000; //the amount of time the robot will pause between segments of the run
	final private static int speed1 = 250; //forward speed
	final private static int speed2 = 150; //backup speed
	final private static double rturncal = 15; //should be around 15
	final private static double lturncal = 13.3; //should be around 15
	final private static double movecal = 2567; //should be around 2567
	final private static double lrcal = 45; //should be around 42 //negative is more left
	
	final public static double tempSlope = -11.05667506; //should be around -11
	final public static double tempIntercept = 3827.700252; //should be around 3800
	final public static double windSlope = 1;
	final public static double windIntercept = 0;
	
	private static boolean notBumped;
	public static int turnmultiplier;
//=====================================================//
	
	public static void main(String[] args) {
	// Initialization
		r.setPort("COM3"); // Set the port to COM3
//		r.setVerbose(true); // Turn on debugging messages
		r.connect();		
		r.attachMotor(RXTXRobot.MOTOR1, motor1pin); //left motor  attach motors
		r.attachMotor(RXTXRobot.MOTOR2, motor2pin); //right motor
		r.attachServo(RXTXRobot.SERVO1, servo1pin); //Connect SERVO1, the boom to servo1pin
		r.attachServo(RXTXRobot.SERVO2, servo2pin); //Connect SERVO2, the pingpong ball arm to servo2pin
		System.out.println();
		
	// Calibration
//		run1.move(1, speed1);
//		run1.turn(360);
//	 	run1.turn(-360);	
//		run1.liftBoom(); 
//		run1.moveUntilBumped();

	// 1. starting box
		run1.startingBox();
	
 	// 2. dynamic wall
 		run1.dynamicWall();
 		r.sleep(2000);
 		
 	// 3. climb onto elevated air region
		run1.move(1, speed1 + 70);
		r.sleep(pausetime);
		
	// 4. raise probe 75cm and take temperature and wind speed readings
		run1.liftBoom();
		r.sleep(pausetime);
		
	// 5. navigate relocatable gap
		run1.navigateRelocatableGap();

	// 6. navigate to bridge
		run1.navigateToBridge();
		
	// 7. cross bridge and navigate to sandbox
		run1.moveUntilBumped();
		run1.move(backup, speed2);
		run1.turn(90);
		run1.moveUntilBumped();
		
	// 8. deploy sensor, test conductivity, and release ping pong ball
		run1.conductivity();

 	// Closing
		System.out.println("Closing in 3");
		r.sleep(1000);
		System.out.println("Closing in 2");
		r.sleep(1000);
		System.out.println("Closing in 1");
		r.sleep(1000);
		r.close();
		
	}
	
	public Run(int x) {
	}
	
	public void turn(int degrees) {
//I'm just guessing on all the numbers here		
		int turnspeed;
		if (degrees > 0) {
			turnspeed = 250;
		} else {
			turnspeed = -250;
		}
		int turntime = getTurnTime(degrees);
		//s was 250 for Sprint 2
		//t was 7700 for Sprint 3

		r.refreshAnalogPins();
		r.runMotor(RXTXRobot.MOTOR1, turnspeed * turnmultiplier, RXTXRobot.MOTOR2, turnspeed * turnmultiplier, 0); // Run both motors forward indefinitely
		r.sleep(turntime); // Pause execution for turntime in ticks, but the motors keep running.
		r.runMotor(RXTXRobot.MOTOR1, 0, RXTXRobot.MOTOR2, 0, 0); // Stop both motors
	}
	
	public void move(double distance, int speed) {
	//	int s = getMoveSpeed(distance);
		int movespeed;
		if (distance > 0) {
			movespeed = speed;
		} else if (distance < 0) {
			movespeed = -1 * speed;
		} else {
			movespeed = 0;
		}
		int movetime = getMoveTime(distance);
		//s was 250 for Sprint 2
		//t was 7700 for Sprint 3
		
		r.refreshAnalogPins();
		r.runMotor(RXTXRobot.MOTOR1, (int)(movespeed - lrcal), RXTXRobot.MOTOR2, (-1 * movespeed), 0); // Run both motors forward indefinitely
		r.sleep(movetime); // Pause execution for movetime ticks, but the motors keep running.
		r.runMotor(RXTXRobot.MOTOR1,0,RXTXRobot.MOTOR2,0,0); // Stop both motors
	}
	
	public void liftBoom() {
//===========Move Servo		
		r.moveServo(RXTXRobot.SERVO1, 5); 
	

//=========== New Temp and Wind reading		
		int datapoints = 10;
		int tempTotal = 0;
		int windTotal = 0;
		
		for (int c = 0; c < datapoints; c++) {
			r.refreshAnalogPins();
			AnalogPin windPin = r.getAnalogPin(windPinNumber); //get pin data
			AnalogPin tempPin = r.getAnalogPin(tempPinNumber); //get pin data
			
			tempTotal = tempTotal + tempPin.getValue();
			windTotal = windTotal + windPin.getValue();
			
			r.sleep(100);
		}
		
		double tempAvg = (double) tempTotal / (double) datapoints;
		double windAvg = (double) windTotal / (double) datapoints;
		double diff = tempAvg - windAvg;
		
		double temp = ((tempAvg - tempIntercept) / tempSlope) - 273;
		double wind = ((diff - windIntercept) / windSlope);
		
		System.out.println("Temperature: " + temp + " degrees Celsius.");
		System.out.println("Wind speed: " + wind + " kph");
//=========== Lower Boom Arm	
//		r.moveServo(RXTXRobot.SERVO1, 180);
		
		
/*=============== old temp and wind readings		
		//=========== Temperature		
				System.out.println("Getting Thermometer reading: ");
				r.refreshAnalogPins(); // Cache the Analog pin information	
				int thermoAnalogPin = 0; //this is the ping pong ball
				 
				int datapoints = 10;
				int[] rawData = new int[datapoints]; 
				int rawTotal = 0;
				
				for (int c = 0; c < datapoints; c++) {
					r.refreshAnalogPins();
					AnalogPin temp = r.getAnalogPin(thermoAnalogPin); //get pin data
					rawData[c] = temp.getValue();
					rawTotal = rawTotal + rawData[c];
				//	System.out.println(c + 1 + "\t" + rawData[c]);
					r.sleep(100);
				}
		    
				double rawAvg = (double) rawTotal / (double) datapoints;
				System.out.println("The probe read the value: " + rawAvg);
				System.out.println("In volts: " + (rawAvg * (5.0/1023.0)));
				
				double slope = -11.05667506;										//was -11.05667506
				double intercept = 3827.700252;										//was 3827.700252
				double temp = ((rawAvg - intercept)/slope)-273;
				System.out.println();
				System.out.println("It is " + (temp + 2.5) + " degrees Celsius");
				
		//=========== Wind readings
				System.out.println("Getting Anamometer reading: ");
				r.refreshAnalogPins(); // Cache the Analog pin information	
				
				int windAnalogPin = 1;
				 
				int Totaltemp1 = 0;
				int Totaltemp2 = 0;
				
				int datapoints2 = 10;
				for (int c = 0; c < datapoints2; c++) {
					r.refreshAnalogPins();
					AnalogPin temp0 = r.getAnalogPin(windAnalogPin); //get pin data
					AnalogPin temp2 = r.getAnalogPin(thermoAnalogPin); //get pin data
					
					Totaltemp1 = Totaltemp1 + temp0.getValue();
					Totaltemp2 = Totaltemp2 + temp2.getValue();
					
					r.sleep(100);
				}
		    
				double Avgtemp1 = Totaltemp1 / datapoints2;
				double Avgtemp2 = Totaltemp2 / datapoints2;
				
				System.out.println("Input 1 = " + Avgtemp1);
				System.out.println("Input 2 = " + Avgtemp2);
				
				//tSlope tIntercept wSlope wIntercept
				
				System.out.println("Temperature : " + tSlope * (Avgtemp2) - ); 
				System.out.println("Wind speed: " + windcal * (Math.abs(Avgtemp1 - Avgtemp2) - 8));
		*/		
	}

	public int getMoveTime(double distance) {
		double dbl = (Math.abs(distance) * movecal);
		int t = (int) dbl;
		return t;
	}
	
	public int getTurnTime(int degrees) {
//TODO calibrate the numbers for turning
		int d;
		if (degrees > 0) {
			d = (int)(Math.abs(degrees) * rturncal);
			return d;
		} else {
			d = (int)(Math.abs(degrees) * lturncal);
		}
		return d;
		}
	
	public boolean detectGap() {
		System.out.println("Running detectGap()");
		if(run1.getPing() < 55) {
			System.out.println("No Gap Detected");
			return false;
		} else {
			System.out.println("Gap Detected");
			return true;
		}
	}
	
	public double getPing() {
		System.out.println("Running getPing()");
		int datapoints = 10;
		int[] rawData = new int[datapoints]; 
		int rawTotal = 0;
		
		for (int c = 0; c < datapoints; c++) {
			rawData[c] = r.getPing(PING_PIN);
			rawTotal = rawTotal + rawData[c];
			r.sleep(20);
		}
		double rawAvg = (double) rawTotal / (double) datapoints;
		System.out.println();
		System.out.println("Distance measured: " + rawAvg);
		return rawAvg;
	}
	
	public void moveUntilBumped() {
		System.out.println("Moving until bumped");
		notBumped = true;
		while(notBumped) { //run this loop until the sensor is bumped
			
			
			//***Should this be outside the while loop?
			r.runMotor(RXTXRobot.MOTOR1, 200, RXTXRobot.MOTOR2, -200, 0); //start the motors
	
			
			
			r.refreshAnalogPins(); 
			AnalogPin temp = r.getAnalogPin(bsAnalogPin); //get pin data
			System.out.println(temp.getValue());
			if(temp.getValue() < 500) { //if the data dips below 500, set the boolean to false, exiting while loop
				System.out.println("BUMPED");
				notBumped=false;
			}
		}
		r.runMotor(RXTXRobot.MOTOR1, 0, RXTXRobot.MOTOR2, 0, 0); //turn off the motors
	}
	
	public void conductivity() {
//========== Lower conductivity arm
		System.out.println("Running conductivity program");
	//	r.moveServo(RXTXRobot.SERVO1, 180); // Move Servo 1 to location 30
	//	r.sleep(4000);
		
//===========Conductivity logic
		r.refreshAnalogPins();
		int conductivity = r.getConductivity();
		int saturation = 500; 
		System.out.println("Conductivity measurement: " + conductivity);
		if (conductivity > saturation) {
			System.out.println("Releasing ping pong ball.");
			r.sleep(1000);
//			r.moveServo(RXTXRobot.SERVO2, 150);
		} else {
			System.out.println("Not releasing ping pong ball.");
		}
	}
	
	public void resetServo(int servo) {
		System.out.println("Resetting servo");
		r.moveServo(servo, 180);
	}
	
	public void startingBox() {
		run1.move(.5, speed1);
		r.sleep(pausetime);
		run1.turn(-90);
		double left = run1.getPing();
		run1.turn(180);
		double right = run1.getPing();
		if (right > left){
			turnmultiplier = 1;
		} else {
			turnmultiplier = -1;
		}
		run1.turn(90);
	}
	
	public void dynamicWall() {
 		run1.moveUntilBumped();
 		run1.move(backup, speed2);
		boolean dynamicwall = true;
 		while (dynamicwall) {
 			if (run1.getPing() < 40) {
 				System.out.println("The wall is still there");
 				continue;
 			} else {
 				System.out.println("The wall has been lifted! Proceeding.");
 				dynamicwall = false;
 				break;
 			}
 		}
	}
	
	public void navigateRelocatableGap() {
		run1.turn(-90);
		r.sleep(pausetime);
		run1.move(1, speed1);
		r.sleep(pausetime);	
		run1.turn(-115);							
		boolean nogap = true;	
		boolean b;
		while(nogap) {
			b = run1.detectGap();		
			if (b == false) {
				System.out.println("no gap.");
				run1.turn(90);
				run1.move(.25,  speed1);
				run1.turn(-90);
			} else {
				System.out.println("gap.");
				run1.turn(90);
				run1.move(.2, speed1);
				run1.turn(-90);
				break;
			}
		}
	}
	
	public void navigateToBridge() {
		run1.move(1, speed1);
		if (run1.getPing() < 50) {
			System.out.println("We will run into the right wall first");
			run1.moveUntilBumped(); 		System.out.println("Line 108");
			run1.move(backup, speed2);		
			
			run1.turn(-90);					System.out.println("Line 112");
			
			run1.moveUntilBumped();
			run1.move(backup, speed2);		System.out.println("Line 116");
			
			run1.turn(90);					System.out.println("Line 119");
			
			run1.moveUntilBumped();			System.out.println("Line 122");
			run1.move((backup / 2), speed2);
			
			run1.turn(90);					System.out.println("Line 126");
		} else {
			System.out.println("We will run into the left wall first, and I don't know what to do.");
		}
		
	}
	
}
